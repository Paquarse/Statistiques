---
title: "Traitement de series"
author: "Pâquarse Delvich Van Mahouvi"
date: "07/02/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr ::opts_chunk$set(comment=NA)
```

#Chargement des packages
```{r}
library(xts)
library(readxl)
library(astsa)
library(ggfortify) #autoplot()
library(forecast)
library(fpp2)
library(seasonal) #decomposition de la serie
library(urca)
```

Ordre traitement (après etape 1) : : log, différence saisonnière puis différence première

# Etape 1 : Inspection de la serie (Statistiques descriptives)

## 1- 1 Valeurs manquantes

```{r}
summary(as.xts(elecequip))
```

## 1 - 2  Valeurs aberrantes

```{r}
## Boxplot de la serie
boxplot(elecequip, horizontal = TRUE, main = "Electrical equipment")
```

## 1- 3 Correction des Jours ouvrées s'il en a 

Bonne_valeyr_a_t = (valeur_a_t * nombre_de_jours_reference) / nombre_jour_ouvert_periode

# Etape 2 : Inspection schema 

```{r}
## Affichage de la série
plot(as.xts(elecequip))

## histogramme de la série + courbe de la droite et courbe de la droite normale
hist(elecequip, probability = TRUE, main = "Electrical equipment", xlab = "")
curve(dnorm(x, mean=mean(elecequip), sd=sd(elecequip)), col="darkblue", lwd=2, add=TRUE, yaxt="n")
lines(density(elecequip), lwd = 2, col = "red")

# Tracer le QQplot de la serie pour le test de normalité
qqnorm(elecequip, main = "Electrical equipment")
qqline(elecequip, col = "red")
```


Regarder si la série suit a peu près une distribution normale. 
Chercher le modèle de décomposition : addictif ou multiplicatif (stationnarité ou non en variance). Prendre le log(de la serie pour reduire la variabilié de la serie ou la transformation Box-Cox)

 - Modele additif : ne rien faire
 - Modèle Multiplicatif : Transformation de Box-Cox avec la bonne valeur de lambda ou prendre le log (à privilégier si rien n'est précisé)

```{r}
#Technique 1 
BoxCox.lambda(elecequip) #Trouver la bonne valeur de lambda et la representé
elecequip %>% BoxCox(lambda = 0.1239192) %>% autoplot()
#Techique 2
plot(log(as.xts(elecequip)))
```
 

# Etape 3 : Inspection composantes

## Etude de la saisonnalité

Tracer les fonctions d'autorrelation simple et partiel des series 

```{r}
acf2(elecequip)
#ou (en fonction de la transformation réalisée)
acf2(log(elecequip))
```
- si décroissance lente de ACF --> serie non stationnaire
- pas de forme particulière pour ACF --> serie stationnaire
- si a un ordre regulier (3, 6, ... par exemple), soupsons de saisonalité

- L'ordre du PACF permet de connaitre l'odre du AR(dernier retard significatif)
Afficher les graphiques de saisonalité 

```{r}
ggseasonplot(log(elecequip)) # increase of seasonal component through time => multiplicative scheme
ggseasonplot(log(elecequip), polar = TRUE)
```

Verifier si la saisonnalité est stable au cours du temps. Les traits bleu representent les moyennes. 

```{r}
ggsubseriesplot(log(elecequip))
```

Si saisonnalité : Desaisonnalisé la série 
Une solution : Si saisonnalité d'ordre 12 par exemple faire differences = 12 dans l'operateur diff() pour stationnarisé (=6 si saisonalité d'ordre 6) de la serie transformée. 
Ou calculer les cvs : corrections des variations saisonnières

```{r}
equi <- diff(log(elecequip), lag = 12)
autoplot(equi)
```

## 3-1 : Etude de la stationnarité : Test de racine unitaire de la serie log(de notre serie/sa transformation Box-Cox)
Regle de décision inversée : (Valeur calculé) < Valeur tabulé --> RHO

Verifier si présence de rupture dans la série (Règle de décision inversée pour la racine unitaire et conservée pour les autres)
- si oui --> Test de PP avec prise en compte de rupture
- si non --> Test de PP

Si correlogramme pas encore tracé, le faire 

### Test de PP (sans rupture) de la serie log(Xt) et respecté la stratégie sequentielle
Règle de décision inversée pour le test de racine unitaire seul (unilatéral)

 Specification of the ur.pp() test:
   - Model 3 (model = "trend")
   - Model 2 (model = "constant")
   - PP test statistic (type="Z-tau") : règle de décision inversée ici
   - Truncation parameter (I_4: lags = "short", I_12 = lags="long")

cf : table de DF pour les stats

trend = 0 , (5%) = 2.79 (1%) = 3.49
constant = 0, (5%) = 3.09, (1%) = 3.74

Pour le test de racine unitaire de PP, la valeur critique et valeur tabulé (Z-tau) sont données 

```{r}
#Modèle 3 
#summary(ur.pp(lop, model = "trend", type = "Z-tau",lags = "short"))
#summary(ur.pp(lop, model = "constant", type = "Z-tau",lags = "short"))
```

## Test de ADF 

 Specification of the ur.df() test:  

C'est le test ADF qui est programmé par defaut dans R
   - Model 3 (type = "trend"), 
   - Model 2 (type = "drift"),
   - Model 1 (type = "none"),

```{r}
#summary(ur.df(lop, type = "trend", lags = 12, selectlags="AIC")) #tt represente la tendance / selectlags permet de dire de choisir le lag qui minimise l'AIC

# Dans ce modèle on ne peut pas utiliser les p-value car ceux ne sont pas ceux de MacKinon, donc on utilise la regle de décision normale pour tendance, constance, none
```

## Test de KPSS (2eme generation) avec HO : statonnaire

```{r}
lop <- log(oilprice)
summary(ur.kpss(log(oilprice), type="tau", lags = "short")) 
```

TEST DE RU : t_kpss = 0.3178 > t-critique = 0.216 à 1% (0.146 à 5%)
Conclusion : tendance DS => On rejette H0 


## Test de stationnarité avec rupture de structure ; Test de Zivot Andrew

Specification of the ur.za(), the Zivot and Andrews unit root test which allows a break at
an "unknown" point in either the intercept, the linear trend or in both:

   - Model A: rupture de la constante(niveau) (model="intercept")
   - Model B: rupture en la tendance(pente) (model="trend")
   - Model C: rupture avec les deux (model="both")

on renseignele type de rupture qu'on pense. Le test nous donne 

```{r}
summary(ur.za(lop, model="intercept"))
```


```{r}
index(lop[127]) # Pour trouver l'index (la date)
```

# Moyenne mobile : ?ma

```{r}
elec_ma12 <- ma(elecequip, 12)
data_elec <- merge(as.xts(elecequip), as.xts(elec_ma12), join = "outer", fill = NA) #Pour verifier
```


# Decomposé une serie 

```{r}
elec_mul <- decompose(elecequip, type="multiplicative")
autoplot(elec_mul)
elec_mul$figure # Contient les moyennes par periodes 

elec_x11 <- seas(elecequip, x11="") # avec census 11 
```

trendcycle() for trend component (E_t), remainder() for R_t, seasadj() for seasonnaly adjusted series X_cvs
































